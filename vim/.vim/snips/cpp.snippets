# cpp.snippets - Snippets for cpp file type

extends c

###########################################################################
#			    Global functions 						  #
###########################################################################

global !p

def write_docstring_args(arglist, snip):
	args = str(arglist).split(',')

	if len(args) > 1:
		c = 0
		for arg in args:
			if c == 0:
				snip.rv += arg
				c = 1
			else:
				snip += '*       : %s' % arg.strip()
	else:
		snip.rv = args[0]


endglobal

snippet cl "class"
class ${1:`!p snip.rv = snip.basename or "ClassName"`} {
public:
	${1/(\w+).*/$1/}(${2:arguments});
	virtual ~${1/(\w+).*/$1/} ();

private:
	${0:/* data */}
};
endsnippet

snippet str "struct"
struct ${1:`!p snip.rv = snip.basename or "StructName"`} {
	${1/(\w+).*/$1/}(${2:arguments});
};$0
endsnippet

snippet func "Basic function template" b
${1:void} ${2:FunctionName}(${3:param}) {
	${0:${VISUAL:}}
}
endsnippet

snippet fnc "Basic C++ doxygen function template" b
/**
* @brief: ${4:brief}
*
* @param: `!p write_docstring_args(t[3], snip)`
*
* @return: `!p snip.rv = t[1]`
*/
${1:void} ${2:FunctionName}(${3:param}) {
	${0:${VISUAL:}}
}
endsnippet

snippet main "int main() {...}" b
int main() {
	${0:${VISUAL}}
}
endsnippet

snippet tp "template <typename ..>"
template <typename ${1:T}>
endsnippet

snippet inc "#include statement" b
#include ${1:<${2:iostream}>}$0
endsnippet

snippet try "try catch statement" b
try {
	${1:${VISUAL}}
} catch (${2:std::string}& ${3:error}) {
	$0
}
endsnippet

snippet map "std::map"
std::map<${1:key}, ${2:value}> ${3:map}$0
endsnippet

snippet umap "std::unordered_map"
std::unordered_map<${1:key}, ${2:value}> ${3:umap}$0
endsnippet

snippet vec "std::vector"
std::vector<${1:int}> ${2:v}$0
endsnippet

snippet cout "Print output to stdout" "snip.visual_text" be
std::cout << ${0:${VISUAL}} << '\n';
endsnippet

snippet cout "Print output to stdout" b
std::cout << ${1:"${2:output}"} << '\n';$0
endsnippet

snippet cerr "Print output to stderr" "snip.visual_text" be
std::cerr << ${0:${VISUAL}} << '\n';
endsnippet

snippet cerr "Print output to stderr" b
std::cerr << ${1:"${2:output}"} << '\n';$0
endsnippet

snippet forin "for in container" b
for (${3:auto}& ${1:value} : ${2:container}) {
	${0:${VISUAL:}}
}
endsnippet

snippet while "while (condition) {}" b
while (${1:true}) {
	${0:${VISUAL:}}
}
endsnippet

snippet formap "for in map" b
for (${3:auto}& [${1:key}, ${2:value}] : ${3:map}) {
	${0:${VISUAL:}}
}
endsnippet

snippet forline "for line in stream" b
for (string ${1:line}; std::getline(${2:std::cin}, $1);) {
	${3:${VISUAL:}}
}
endsnippet

snippet if "Simple if statement" b
if (${1:0 == 0}) {
	${0:${VISUAL:}}
}
endsnippet

snippet ifreg "If regex match" b
std::smatch ${1:matches};
if (std::regex_search(${2:string}, $1, ${3:pat})) {
	${4:${VISUAL:}}
}
endsnippet

snippet regex "Regex pattern" b
std::regex ${1:pattern} {R"(${2:${VISUAL:pat}})"};
endsnippet

snippet optcout "Avoid overhead with C standard out/input" b
std::ios_base::sync_with_stdio(false);$0
endsnippet

snippet timeit "Time the code" b
auto t0 = std::chrono::high_resolution_clock::now();
${VISUAL}$0
auto t1 = std::chrono::high_resolution_clock::now();
std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(t1 - t0).count() << "\n";
endsnippet

snippet random "Get a small random dist template" b
// Random numbers in [$2]
std::default_random_engine re;
std::uniform_${1:int}_distribution<> dist {${2:1, 6}};
auto ${3:get_random} = [&](){ return dist(re); };
endsnippet

snippet switch "Switch statement" b
switch (${1:${VISUAL}}) {
	case ${2:firstCase}:
		${3:Do when $2}
		break;$0
}
endsnippet

snippet bmfnc "Google Benchmark function" b
static void BM_${1:func_name}(benchmark::State& state) {
	for (auto _ : state) {
		${2:${VISUAL}}$0
	}
}
BENCHMARK(BM_$1);
endsnippet

snippet anyof "std::any_of" b
std::any_of(${1:container}.begin(), $1.end(), [](${2:int ${3:i}}) { return ${4:$3 > 0}; });
endsnippet

# Skeletons
snippet _header "Header skeleton file" b
#pragma once

$0
endsnippet
